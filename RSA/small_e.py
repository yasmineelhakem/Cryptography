import gmpy2

n=88967858626403829064090168810122868285182786219180688746145621925572261870842585807647581429042818788916887616276051398246293021638131627012320614205468717940317673162455006414540388678626858847903195216295364522964630658586923780704987095796917400163216838273842136148485462814042836563626411016446370840523
e = 3
c=384012444224419778535285605040325306748190826239683049492013551154174481922834799900628466728718167765940461665510809493931176037

# c=m**e mod(n) => c=m**e+nk  => m**e=c+nt
#iroot ntay7ou biha l puissance
for i in range(10000):
    m, is_true_root = gmpy2.iroot(i*n + c, e)
    if is_true_root:
        print(f"Found i = {i}")
        print("Message: {}".format(bytearray.fromhex(format(m, 'x')).decode()))
        break

""" if e==1:
ciphertext=plaintext
"""

from Crypto.Util.number import long_to_bytes
N = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767
e = 1
cipherText = 44981230718212183604274785925793145442655465025264554046028251311164494127485
plainText = cipherText
print(long_to_bytes(plainText))

""" if we have very small e and very big n:
The idea here is that e=3 is pretty small whereas n is big, so it is possible that pow(m,e) is inferior to n
so c, which is pow(m,e,n) would probably simply be c=pow(m,e)
yaani l n zeyda mech bech nestaamlouha juste ntay7ou l cube(e)

"""
from gmpy2 import iroot
c = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957
print(bytes.fromhex(hex(iroot(c, 3)[0])[2:]))